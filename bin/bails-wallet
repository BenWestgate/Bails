#!/bin/bash
# Installs Bitcoin core to Tails, creates a passphrase fallback and backup Tails USB sticks
# Parameters:
#		$1 = Locations needed to restore a forgotten passphrase
#		$2 = Total locations to store data at
#		$3 = Good signatures to verify the Bitcoin download
#		$4 = --refresh-keys, optional, used if updating Bitcoin Core
# For security reviewing this use: https://explainshell.com/ for commands that are unclear.

# TODO FOR L1. After restoring, ask if the user has forgotten their passphrase, if they suspect
# it has been compromised or if any share has been lost or suspected compromised.
# Stolen will advise to create a new wallet and sweep funds. It will also increment the threshold.
# Lost will add shares only (without rotating the backup), or decrement the threshold if no new
# backup locations are available.

# TODO FOR L2 provide an option for persistent "hot" restore and offline "cold" restore. The offline keeps
# the private wallet in RAM and requires restoring from seed each time to sign transactions.
# Creates a watch-only. persistent saves public or private key wallets to persistent storage.


# unset environment variable so bitcoin-qt can launch without wayland.
unset QT_QPA_PLATFORM

# Needed for zenity dialogs to have window icons 
export WAYLAND_DISPLAY=""
export DOTFILES=/live/persistence/TailsData_unlocked/dotfiles
export LOCAL_DIR=$DOTFILES/.local
export DATA_DIR=/live/persistence/TailsData_unlocked/Persistent/.bitcoin
export ICON="--window-icon=$LOCAL_DIR/share/icons/bails128.png"
export CLI="bitcoin-cli -rpcport=17600"
# set PATH environment variable to include ~/.local/bin
export PATH="${PATH}:${HOME}/.local/bin"

hrp=ms1
string=string
secret_or=' secret or'
ICON="--window-icon=$LOCAL_DIR/share/icons/bails128.png"


###################
# Creates generator wallet, gets address, gets its extended private masterkey, leaves no traces behind
# Note: bitcoind must already be running or 'Enable RPC Server' checked in GUI options and restart.
###################
get_strong_rand_bytes() {
    temp=$(mktemp)		# temporary filename
    shred --remove $temp	# delete file to make room for wallet
    key="$(head -c64 /dev/urandom | base64 --wrap=0)"	# 64 byte wallet encryption key to crypto-shred the wallet
    $CLI createwallet $temp false false "$key"
    $CLI -rpcwallet=$temp walletpassphrase "$key" 60	# unlocks generator wallet for 1 minute
    extended_private_masterkey="$($CLI -rpcwallet=$temp listdescriptors "true" | grep --max-count=1 -oP '(?<=tr\().*?(?=/)')"
    $CLI -rpcwallet=$temp walletlock
    $CLI -rpcwallet=$temp unloadwallet
    find $temp -type f -exec shred --remove {} +	# shreds the temporary wallet in memory by overwriting randomness
    rm -Rf $temp
    unset $key $temp # deletes encryption key from memory
    if [ ${extended_private_masterkey:0:4} != 'xprv' ]; then
        zenity --warning --title='Failed to get Bitcoin Core entropy' --text='Bitcoin core may not be running or the RPC server got disabled.' $ICON & 
        exit 1
    fi
}

user_randomness () {
    if zenity --info --icon-name=die2 --question --width=400 --title="Help randomize new seed" --cancel-label='Skip' --ok-label='Add Randomness' --text="• Your seed is a secret that allows spending your bitcoin as long as you have access to it.\n\n• Bitcoin Core will generate a random seed, but it is good to provide extra randomness if paranoid.\n\n• This is unnecessary but it will protect against a backdoored random number generator.\n\n• You can not hurt your seed's randomness no matter what data you provide, it can only help." $ICON; then
        until zenity --entry --title='Add Randomness' --text="Provide additional randomness and click OK.\n\nA good way to create randomness is to roll a 6-side dice 50+ times or\nflip a coin 128+ times.  A fast way is mashing the keyboard." $ICON; do : ; done
    fi
}


###################
# Sets global variables for dialog grammar
###################
tn_grammar() {
    ((locations > 2)) && plur=s || plur=''
    ((threshold-2)) && { plurt=s ;plurtt=are; } || { plurt=''; plurtt=is; }
    ((locations-threshold)) && plurl='s' || plurl=''
    ((threshold > 1 )) && { string='share'; password_derived="\nAn additional <b>1</b> share is formed by your <b>passphrase</b>." ; password_steal=", OR <b>$((threshold-1))</b> share$plurt and your passphrase" ; password_loss=", OR <b>$((locations-threshold+1))</b> location$plurl and your passphrase"; plurts=are; plurtss='s'; } || { plurts=is; string='secret' ; unset plurtss password_derived password_steal password_loss; }
    ((locations < 2)) && { plurs=''; pronoun='it'; } || { plurs='s'; pronoun='them'; }
}


ask_t_and_n () {
    # Explain the seed backup and what conditions will recover the seed
    # allows tweaking it or skipping it in a 'Change Something' dialog TODO decide best formatting in Tails
    tn_grammar
    until $(zenity --question --icon-name=org.gnome.gedit --title="$threshold-of-$locations codex32 seed backup" --text="<big>In case all Bails USBs fail or you lose your passphrase, we will split your seed into <b>$locations</b> codex32 $string$plurs across <b>$locations location$plurs</b>, with <b>any $threshold</b> of those ${string}s able to restore your seed by typing $pronoun into a codex32-enabled wallet such as Bails.$password_derived</big>\n\nYou will need:\n\t• $locations piece$plurs of paper about the size of an index card\n\t• Pen or pencil\n\t• Hard surface to write on to avoid leaving an imprint of the secret\n\nOne $string can stay hidden near this Bails USB and the others will go offsite, one to each of your backup locations.\n\n-If <b>$threshold</b> $string$plurtss $plurts stolen$password_steal, an attacker can <b>STEAL</b> your bitcoins.\n\n-If <b>$((locations-threshold+2 > locations ? locations : locations-threshold+2))</b> location$plurs are lost$password_loss, you will <b>NOT</b> be able to recover your seed.\n\nDo you understand?" --cancel-label='Change Something' --width=520 $ICON); do
        backup_choice="$(zenity --title='Change backup parameters' --question --extra-button='Location Quantity' --extra-button='Threshold' --switch --text="Location quantity is how many places you will store a codex32 $string.\n\nThreshold is how many shares are needed to steal or recover your seed.\n\nWhat would you like to change?" --ellipsize $ICON)"
        [ "$backup_choice" == 'Location Quantity' ] && locations=$(zenity --scale --text="How many total locations do you want to store ${string}s at?\n\nMinimum $threshold is for low value data.\nUse $((threshold+2)) or more for high value data." --min-value=$threshold --value=$locations --max-value=$((locations+threshold*3-1 < 30 ? locations+threshold*3-1 : 30)) --title='Location quantity' $ICON)
        [ "$backup_choice" == 'Threshold' ] && threshold=$(zenity --scale --text='How many locations do you want required to recover or steal your seed?\n\nMinimum 2 for low value data.\nUse 3 for high value data.' --min-value=1 --max-value=$((locations < 9 ? locations : 9)) --value=$((locations == 5 ? threshold : $(( locations < 5 ? 2 : 3)))) --title='Recovery threshold' $ICON)
        (( threshold < 2 )) && { zenity --question --icon-name=dialog-warning --title='Security warning' --text='<b>Caution</b>: Setting the threshold to <b>1</b> means anyone who finds a single location can <b>STEAL ALL YOUR BITCOIN</b>, even without your passphrase.\n\nThis is not recommended, are you sure you want to do this?' --default-cancel --width=400 $ICON || threshold=2; }
        (( threshold > 3 )) && { zenity --question --icon-name=dialog-warning --title='Safety warning' --text="<b>Caution</b>: Higher threshold values than <b>3</b>, in our view, are a bad trade-off between usability and robustness (which are damaged) and security (which is improved).\n\nThis is not recommended, are you sure you want to use threshold <b>$threshold</b>?" --default-cancel --width=440 $ICON || threshold=3; }
        # reset the variables to sensible values if exited
        tn_grammar
    done
}

input_share() {
if [ "$choice" == "Create a new seed" ]; then
    title="Create Bails Wallet: Enter your codex32 $string $progress"
    unset entry
    action='Create'
    
else
    title="Restore Bails Wallet: Enter a codex32$secret_or share $progress"
    entry=$hrp$threshold$identifier
    action='Restore'
fi
unset corr
[ "$share" ] && { entry="$share"; title="$action Bails Wallet: Re-enter your codex32 $string"; corr=' corrected'; }
share="$(zenity --title="$title" --entry --entry-text="$entry" --text="Type your$corr codex32 $string:" --width=650 $ICON)"
[ "$share" ] || return 1
hrp_in="${share:0:3}"
data="${share:3}"
if [[ "$share" == *'b'* ]]; then
    data="${data//b/6}"
    zenity --notification --text='Detected non-bech32 character "b"' $ICON
fi
if [[ "$share" == *'i'* ]]; then
    data="${data//i/l}"
    zenity --notification --text='Detected non-bech32 character "i"' $ICON
fi
if [[ "$share" == *'o'* ]]; then
    data="${data//o/0}"
    zenity --notification --text='Detected non-bech32 character "o"' $ICON
fi
if [[ "$share" == *'B'* ]]; then
    data="${data//B/8}"
    zenity --notification --text='Detected non-bech32 character "B"' $ICON
fi
if [[ "$share" == *'I'* ]]; then
    data="${data//I/L}"
    zenity --notification --text='Detected non-bech32 character "I"' $ICON
fi
if [[ "$share" == *'O'* ]]; then
    data="${data//O/0}"
    zenity --notification --text='Detected non-bech32 character "O"' $ICON
fi
if [[ "$data" == *'1'* ]]; then
    data="${data//1/l}"
    zenity --notification --text='Detected non-bech32 character "1" in data portion' $ICON
fi

share="$hrp_in""$data"
threshold="${share:3:1}"
identifier="${share:4:4}"
index="${share:8:1}"
if [[ $index ]] && [[ ${index,,} != 's' ]]; then
    string=share
elif [[ ${index,,} = 's' ]] || [[ $threshold = 0 ]]; then
    string=secret
else
    string=string
fi
if [[ "$share" = "${share^^}" ]]; then
    hrp=${hrp^^}
    identifier="${identifier^^}"
elif [[ "$share" != "${share,,}" ]]; then
    zenity --title='Mixed case is not allowed' --error --text="A codex32 $string MUST be entirely uppercase or entirely lowercase." $ICON --ellipsize
    return 1
else
    hrp="${hrp,,}"
    identifier="${identifier,,}"
fi

if [[ "$share" =~ [^a-zA-Z0-9] ]]; then
    zenity --title='Found non-alphanumeric character in '$string --error --text="Codex32 ${string}s contain only letters and numbers." $ICON --ellipsize
    return 1
fi

if [[ "$hrp_in" != $hrp ]] ; then
    zenity --title='Wrong human-readable prefix' --error --text='Codex32 '$string's start with "'$hrp'".\n\nYou typed "'$hrp_in'".' $ICON --ellipsize
    return 1
fi
if [[ $threshold = 0 ]]; then
    if [[ ${index,,} != 's' ]]; then
        zenity --title='Bad share index' --error --text='Share index (9th character) must be "'${hrp:1:1}'" when threshold is "0".\n\nYou typed "'$index'".' $ICON --ellipsize
        return 1
    fi
elif (( threshold < 2 || threshold > 9 )) ; then
    zenity --title='Bad threshold' --error --text='Threshold parameter (4th character) MUST be a single digit between "2" and "9", or the digit "0".\n\nYou typed "'$threshold'".' $ICON --ellipsize
    unset threshold
    return 1
fi
if (( ${#share} < 48 )); then
    zenity --title='Entry too short' --error --text="Codex32 ${string}s are at least 48 characters.\n\nYou typed ${#share} characters." $ICON --ellipsize
    return 1
elif (( ${#share} > 93 && ${#share} < 96 )); then
    zenity --title="Illegal codex32 ${string} length" --error --text="Codex32 ${string}s are 48 to 102 characters or 105 to 127 characters.\n\nYou typed ${#share} characters." $ICON --ellipsize
    return 1
elif (( ${#share} != 74 && ${#share} != 48 && ${#share} != 127 )); then
    zenity --title='Unusual length' --warning --text="Codex32 ${string}s are usually 48, 74 or 127 characters long.\n\nYou typed ${#share} characters." $ICON --ellipsize
fi

# call checksum verification function here
return $(python3 -c 'from codex32 import ms32
ms32.verify_checksum("'$share'")')
}

get_share() {
    threshold="${share:3:1}"
    unset share
    until input_share; do
        zenity --notification --text="Invalid checksum. Please correct all errors and try again." $ICON
    done
    if [[ " ${share_list[*]} " =~ " ${share,,} " ]]; then
        zenity --notification --text="You have input the same share twice.\nPlease input a unique share." $ICON
        get_share
    fi
    share_list+=(${share,,})
}

get_passphrase() {
    unset new_kdf_share share_list[1]
    if zenity --title='Restore Bails Wallet: Seed backup passphrase' --question --text="Do you remember your seed backup's passphrase?" --width=300 $ICON; then	#TODO check & fix dialog formatting
        until [ "$passphrase" ]; do
            passphrase="$(zenity --title='Enter your Bails backup passphrase' --password $ICON)"
        done
        share_list[1]=$(python3 -c 'from codex32 import ms32
k, identifier, share_index, decoded = ms32.decode("ms", "'$share'")
codex32_kdf_share, salt , indices_free = ms32.kdf_share("'"$passphrase"'", k, identifier, len(decoded))
print(codex32_kdf_share)')
    else
        unset share_list[1]
        #TODO for offline restores do not reset if forgotten, no passphrase is needed
        set_passphrase 'Restore Bails Wallet: Reset passphrase'
        new_kdf_share=$(python3 -c 'from codex32 import ms32
k, identifier, share_index, decoded = ms32.decode("ms", "'$share'")
codex32_kdf_share, salt , indices_free = ms32.kdf_share("'"$passphrase"'", k, identifier, len(decoded))
print(codex32_kdf_share)')
    fi
}

recover_seed() {
    py_share_list="${share_list[*]}"
    py_share_list=${py_share_list// /"','"}
    printf "$(python3 -c "from codex32 import ms32
print(ms32.recover_master_seed(['"$py_share_list"']))
")"
}

get_codex32_secret() {
    [ "$threshold" ] || get_share
    [ "$passphrase" ] || get_passphrase
    echo ${#share_list[*]} $threshold
    ((${#share_list[*]} < threshold)) && get_share
    if [[ ${index,,} = 's' ]]; then
        codex32_secret="$share"
        reset='your codex32 secret'
        threshold=1
        return 0
    fi
    unset secret_or
    reset="$threshold shares"
    while ((${#share_list[*]} < threshold)); do
        progress="($((1+${#share_list[*]})) of $threshold)"
        get_share
    done
    codex32_secret="$(recover_seed)"
    if ! [ "$confirm" ]; then
        ((${#share_list[*]} > 2)) && plur='s'
        while (( $(python3 -c 'from codex32 import ms32
ms32.identifier_verify_checksum("'$codex32_secret'")') )); do
            zenity --notification --text="The passphrase you entered does not match your share$plur.\nPlease double-check your password and try again." $ICON
            unset passphrase
            get_codex32_secret
            return 1
        done
        zenity --notification --text="Passphrase verified.\nThe Bails backup passphrase you entered matches your share$plur." $ICON
#    else
#        if (( $(python3 -c 'from codex32 import ms32
#ms32.identifier_verify_checksum("'$codex32_secret'")') == 0)); then
#            share_list[1]=$new_kdf_share
#            new_codex32_secret="$(recover_seed)"
#            if [ "$new_codex32_secret" != "$codex32_secret" ]; then
#                zenity --warning --title='Create new codex32 backup now' --text='Passphrase was changed.\n\n<b>A new backup needs to be created immediately.\n\nIMPORTANT: Any previous backups you have made of your seed should be replaced with a newly generated set of codex32 shares. Previous backups of your seed will be useless to restore your wallet using the new passphrase.</b>' $ICON
#                threshold=${codex32_secret:3:1}
#                locations=$((threshold*2-1))	# adds an extra location because user is forgetful.
#                ask_t_and_n                
#                zenity --notification --text="Generating your codex32 backup..."
#                codex32_array=($(python3 -c 'from codex32 import ms32
#ms32.rotate_shares("'$codex32_secret'","'$threshold'",'$locations',"'"$passphrase"'")'))
#                unset share_list new_codex32_secret
#                display_confirm ${codex32_array[*]}
#            fi
#        fi
    fi
    return 0
}

###################
# Asks user if backup compromised or lost #TODO post-pone for L1
# Parameters: $1 = dialog title
###################	#TODO check the titles fit the dialogs in Tails
rotate_backup() {
    if zenity --question --title='Compromised share or passphrase?' --text="Do you know (or suspect) this backup\'s passphrase or any of its shares have been lost or compromised?" --default-cancel $ICON; then
        zenity --warning --title='Backup is vulnerable to theft' --text="Backup security is compromised.\n\n<b>A new codex32 backup needs to be created immediately and old backups destroyed.\n\nIMPORTANT: Any previous backups you have made of your seed should be replaced with a newly generated set of codex32 shares then <b>destroy the previous backups</b>. Previous backups are vulnerable to being restored using your compromised data.\n\nIf you cannot destroy ALL remaining old shares to this backup, or you know (or suspect) $threshold shares OR $((threshold-1)) share(s) and your passphrase are compromised you should Create a new wallet using a new passphrase and sweep all funds immediately using the most urgent transaction fee.</b>" $ICON
    elif zenity --question --title='Lost share or passphrase?' --text="Do you know (or suspect) this backup\'s passphrase or any of its shares have been lost?" --default-cancel $ICON; then
        zenity --warning --title='Backup is vulnerable to loss' --text='Backup safety is compromised.\n\n<b>A new codex32 backup needs to be created immediately.\n\nIMPORTANT: Any previous backups you have made of your seed should be replaced with a newly generated set of codex32 shares. Previous backups of your seed will be useless to restore your wallet using a new passphrase or share.</b>' $ICON
    fi
}

###################
# Sets or Resets passphrase with confirmation
# Parameters: $1 = dialog title
###################	#TODO check the titles fit the dialogs in Tails
# TODO passphrase strength meter must be provided.  Can use zenity --Progress to make it graphical
# Do NOT permit default, weak, or well-known passwords, such as "Password1" or "admin/admin".

set_passphrase() {
    until [ "$passphrase" ] && [ "$passphrase" = "$confirm" ]; do
        passphrase_reply="$(zenity --forms --add-password='Passphrase:' --add-password='Confirm:' --text='We recommend using the same passphrase as your current\nTails so that the passphase is easier to remember.' --title="$1" $ICON)"
        if [ "$passphrase_reply" != '|' ]; then
            passphrase="$(echo -n "$passphrase_reply" | cut -f1 -d'|')"
            confirm="$(echo -n "$passphrase_reply" | cut -f2 -d'|')"
            if [ "$passphrase" != "$confirm" ]; then
                zenity --warning --text='The passphrases do not match.' --title="$1" --ellipsize $ICON
            fi
            if (( ${#passphrase} < 2 )); then	#TODO FIXME change this to 12 after testing
                zenity --warning --text='A random passphrase of at least 12 characters MUST be used.' --title="$1" --ellipsize $ICON
                unset passphrase
            fi
        else
            zenity --warning --text='No passphrase was entered.\n\nA passphrase is required to send bitcoin.' --title="$1" --ellipsize $ICON
        fi
    done
    # remove passphrase from memory
    unset passphrase_reply
}
###################
# Displays shares for user to write and confirms they were written then restores
# Parameters: $* an array of the shares
###################
display_confirm() {
    #TODO display and confirm all n shares.
    echo $*	# TODO remove after testing
    for codex32_string in ${codex32_array[*]}; do
        displayed=$(echo "$codex32_string" | sed 's/.\{4\}/& /g')	# adds space every 4 chars
        x=$((backups_made++))
        ((x==1)) && backup=' Backup'
        ((x==2)) && backup=' second Backup'
        ((x==3)) && backup=' third Backup'
        ((x>3)) && backup=" ${x}th Backup"
        progress="($backups_made of $locations)"
        unset share
        until [ "$codex32_string" == "$share" ]; do
            zenity --title="Create Bails Wallet: Seed backup $progress" --text="Write this $string legibly:\n\n<big><big>$displayed</big></big>" --info --icon-name=org.gnome.gedit --width=600 $ICON
            choice="Create a new seed"
            input_share
            if [ "$codex32_string" == "$share" ]; then
                zenity --info --title="Confirmed $string" --text="Codex32 $string $backups_made of $locations successfully confirmed.\n\nYou will store this paper $string in a secure place near your$backup Bails USB: either under lock and key or hidden where only you or heirs will find." --ellipsize $ICON --width=400
            else
                # save last entered text to save the user time trying again.
                zenity zenity --warning --title="Try again" --text="The supplied $string does not match $string ${progress:1: -1}." --ellipsize --timeout=3 $ICON
            fi
        done
    done
    progress="(1 of $threshold)"
    unset passphrase threshold identifier backups_made share_list choice backup
    zenity --info --title='Create Bails Wallet: Seed backup complete' --text='Seed backup is complete. You will now restore your seed with it before your wallet is created.' $ICON --width=320 #TODO check formatting of this in Tails
}
###################
# Modifies a just restored backup to add security or safety #TODO postpone for L1
###################
modify_backup() {
    ((threshold-2)) && { plurt=s ;plurtt=are; } || { plurt=''; plurtt=is; }
    selection=$(zenity --question --title='Modify backup?' --text="Do you know (or suspect) this backup's passphrase or a share is compromised or lost?\n\n-If no, then select 'No'.\n\n-If compromised or to raise threshold you should select 'Add Security'.\n\n-If lost anything or to create extra shares you should select 'Add Safety'." --switch --extra-button='No' --extra-button='Add Security' --extra-button='Add Safety' $ICON)
    if [ "$selection" = 'Add Security' ]; then
        zenity --question --window-icon=warning-dialog --title='Add Security' --text="Backup security is reduced or compromised if a share or passphrase has been compromised.\n\n<b>A new codex32 backup needs to be created immediately and old backups destroyed, if possible.\n\nIMPORTANT: Any previous backups you have made of your seed should be replaced with a newly generated set of codex32 shares and then destroy previous backups, if possible. Previous backups are vulnerable to being restored using compromised data.</b>\n\n-If you know (or suspect) a share or passphrase are compromised AND/OR you know (or suspect) you can not destroy ALL previous shares, select '<b>Create New Seed</b>'. Then immediately sweep all funds to the new wallet using the most urgent transaction fee.\n\n-Otherwise select '<b>Increase Threshold</b>' which improves security but preserves your wallet." --ok-label='Increase Threshold' --default-cancel --cancel-label='Create New Seed' $ICON	#TODO make sure it rejects the previously used passphrase
        #TODO add functionality to these buttons
    elif [ "$selection" = 'Add Safety' ]; then
        zenity --question --title='Add Safety' --text="Backup safety is reduced if you lose a share or passphrase.\n\n<b>A new codex32 backup needs to be created immediately if you forgot your passphrase.\n\nIMPORTANT: Any previous backups you have made of your seed should be replaced with this newly generated codex32 backup. Previous backups of your seed will be useless for recovery with your new passphrase.</b>\n\n-If the passphrase is lost or to reduce threshold select '<b>New Backup</b>'.\n\n-If you know (or suspect) any shares are lost or to increase safety select '<b>Generate Extra Shares</b>'." --default-cancel --cancel-label='Rotate Shares' --ok-label='Generate Extra Shares' $ICON
        #TODO add functionality to these buttons
    fi
}

#######################################
# Derives xprv from codex32 secret and imports BIP44/49/84/86 descriptors
# Parameter $1: 'now' for new wallets and '0' for wallet restores
# Parameter $2: (optional) load_on_startup True False
#######################################

restore_wallet() {
    echo $codex32_secret	#TODO remove after testing
    xprv=$(python3 -c 'from codex32 import ms32
from electrum import bip32
y = bip32.BIP32Node
print(y.from_rootseed(bytes(ms32.decode("ms","'$codex32_secret'")[3]), xtype="standard").to_xprv())')
    echo $xprv
    # TODO for L2 offline restores do not encrypt or persist signing wallet /tmp/$tmp_dir/$name
    until $CLI createwallet "$name" false true "$passphrase"; do
        name=$(zenity --title='Create wallet failed: name already exists' --entry --text='New Wallet Name:' --entry-text="Wallet $RANDOM" $ICON);
    done
    zenity --title='Wallet encryption info' --width=500 --info --text="Wallet encryption prevents people who steal your wallet file from automatically getting access to all of your bitcoins. Your passphrase must be entered before sending coins.\n\nWallet encryption may prevent unauthorized access. However, it increases the risk of losing coins due to forgotten passphrases. There is no way to recover a passphrase. But it can be reset by finding $reset.\n\nWallet encryption may also not protect against more sophisticated attacks. An attacker can, for example, obtain the password by installing a keylogger on your machine." $ICON
    zenity --title="Wallet encryption warning" --width=500 --warning --text="If you lose your passphrase and can not find $reset, you will\n<b>LOSE ALL OF YOUR BITCOINS</b>\!" $ICON
    zenity --title="Wallet to be encrypted" --width=500 --warning --text="Your wallet is about to be encrypted. Remember that encrypting your wallet cannot fully protect your bitcoins from being stolen by malware infecting your computer." $ICON
    zenity --notification --text='Importing your wallet. This may take several minutes...\nPlease lock the screen if you need to walk away from your PC.' $ICON
    { sleep 5; tails-screen-locker &>/dev/null; } &
    for change in 0 1; do
        ((change)) && internal=true || internal=false
        path="'/0'/0'/$change/*)"
        for desc in "pkh($xprv/44$path" "sh(wpkh($xprv/49$path)" "wpkh($xprv/84$path" "tr($xprv/86$path"; do
            checksum=$($CLI getdescriptorinfo "$desc" | awk 'NR==3 {print $2}')
            # unlocks wallet 1 minute
            $CLI -rpcwallet="$name" walletpassphrase "$passphrase" 60
            $CLI -rpcwallet="$name" importdescriptors '[{ "desc": "'$desc#${checksum:1:8}'", "active": true, "timestamp": '$1', "internal": '$internal' }]'
            $CLI -rpcwallet="$name" walletlock
        done
    done
    $CLI unloadwallet "$name"	# bech32m taproot addresses don't show in GUI until after a reload
    $CLI loadwallet "$name" $2
    return 0
}

### Begins Execution Here ###

name=$(zenity --title='Create Bails Wallet' --entry --text='Wallet Name:' --entry-text='Wallet' $ICON)
[ "$name" ] || name='Wallet'
choice=$(zenity --list --radiolist --title "Create Bails Wallet" --column "Select" --column "Menu Item" \
  --text='Do you want to make a new seed, or use an existing seed?' TRUE "Create a new seed" FALSE \
  "I already have a seed" FALSE "Import descriptors" $ICON)
if [ "$choice" == "Create a new seed" ]; then
    until zenity --warning --title='Two things you must understand' --text='With bitcoin, you are your own bank. No one else has access to your private keys.\n\nIf you lose access to your Bails USB sticks and the seed backup we will help you create, your bitcoin cannot be recovered.' --ok-label='I Understand' --width=420 $ICON; do zenity --notification --text='You must understand these risks.'; done #TODO check the formatting of this in Tails!
    zenity --question --title='Security level' --text='Bails lets you choose the backup that suits your needs.\n\n<b>Low value</b>: Storing and transacting amounts less than <b>2 months of expenses</b>.\nRequires <b>2</b> safe locations.\n\n<b>High value</b>: Storing and transacting amounts less than <b>6 months of expenses</b>.\nRequires <b>3-4</b> safe locations.\n\nA safe location is one where it is unlikely to be lost or found by a bad actor.\nOne compromised backup location can not jeopardize your privacy or funds.' --width=500 --cancel-label=Low --ok-label=High $ICON && { locations=4; threshold=3; } || { locations=2; threshold=2; }
    set_passphrase 'Create Bails Wallet: Set passphrase'
    user_entropy="$passphrase"
    user_entropy+="$name$(user_randomness)"
    ask_t_and_n
    user_entropy+="$threshold$locations"
    zenity --notification --text="Generating your codex32 backup..." $ICON
    get_strong_rand_bytes
    echo "App Entropy: $extended_private_masterkey"
    codex32_array=($(python3 -c 'from codex32 import ms32
master_seed = ms32.fresh_master_seed(16,"'"$user_entropy"'","'"$extended_private_masterkey"'")
id = ms32.seed_identifier(master_seed)
if "'$threshold'" == "1":
    codex32_secret = ms32.encode("ms", 16, "0", id, "s", list(master_seed))
    for i in range('$locations'):
        print(codex32_secret)
else:
    ms32.existing_master_seed(master_seed,"'$threshold'",id,'$locations',"'"$passphrase"'")'))
    (display_confirm ${codex32_array[*]})
    unset choice passphrase confirm user_entropy threshold locations extended_private_masterkey codex32_array
    get_codex32_secret
    restore_wallet '"now"' True	# scans blockchain from current time
elif [ "$choice" == "I already have a seed" ]; then
    get_codex32_secret
    restore_wallet 1689105447 True	# scans blockchain from Jul 11, 2023 for transactions
elif [ "$choice" == "Import descriptors" ]; then
    echo 'Not yet implemented.'	#TODO postpone for L2 -- import descriptors should give a text entry, file select or QR scanner option.
    bails-wallet
else
    exit 1
fi
exit 0

# the extended_private_masterkey + user_entropy go thru Scrypt and the output determines master seed
# master seed determines identifier
# passphrase & master seed determine shares, and share indexes deterministically.  So one extended_private_masterkey + user_entropy + threshold + passphrase always makes the same wallet AND the same share backup.

# it should accept .bsms files ???
# L4 the multisig wallets by default, must not have their public keys visible with just the memorized passphrase
# it is superior to use last 10 characters of any share as the "watch passphrase", although adding a memorized passphrase should be an option.

# Min security: Can sign transactions online.
# Medium security: Bails restarts with networking off to restore the seeds whos keys are only held in RAM. The script exits when networked. Uses persistent storage to pass the PSBT
# Max security: separate offline only Bails USB and dedicated offline PC that never goes back online after creating seed backup or is even destroyed. Uses QRs to pass the PSBT.
# PSBT should never be stored in plaintext in the persistent storage but should have the same privacy level as the watch only wallet. They should be carried in the same encrypted loop-back file.


# seed is account 0, first share is account 1 and so forth
# the watch-only is a loopback file encrypted by hash160||identifier of the master seed.
# max privacy = 2 shares are required to open the watch-only
# this means each loopback file has a shamir share of the hash160||identifier split at threshold 2
# normal privacy = 1 share
# this hash+identifier is stored in the 32 loopback files and automatically unlocks the watch only 
# low privacy = passphrase
