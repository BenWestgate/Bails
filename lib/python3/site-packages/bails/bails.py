#!/bin/python3
#

import codex32
import hashlib
import random

index_list = ['q','p','z','r','y','9','x','8','g','f','2','t','v','d','w','0','3','j','n','5','4','k','h','c','e','6','m','u','a','7','l']
derived_share_list = []

def new_seed(

def identifier_is_seed_id(master_seed):
    h = hashlib.new('ripemd160')
    h.update(master_seed)
    hd_seed_id = h.digest()
    for char in codex32.convertbits(list(hd_seed_id), 8, 5)[:4]:
        identifier += codex32.CHARSET[char]
    return identifier

def generate_shares(n, ms32_master_seed):
    k, identifier, share_index, decoded = codex32.decode(ms32_master_seed)
    if k=='0':
        return [ms32_master_seed] * n
    bytes_for_shares = int(k) * 16
    derived_shares_qty = int(n) - int(k)
    share_entropy = hashlib.scrypt(password=bytes(k+n+identifier,"utf"), salt=bytes(decoded), n=1048576, r=8, p=1, maxmem=1025*1024*1024, dklen=bytes_for_shares)
    share_list = [ms32_master_seed]
    index_entropy = share_entropy[-16:]
    random.seed(a=index_entropy)
    share_index = random.sample(index_list, int(n))
    for x in range(int(k) - 1):
        data = list(share_entropy[x*16:x*16+16])
        share_list += [ codex32.encode("ms", k, identifier, share_index[x], data) ]
    for x in range(int(k),int(n)):
        derived_share_list += [ codex32.ms32_encode("ms",derive_new_share(share_list,share_index[x])) ]
    return share_list[1:] + derived_share_list
